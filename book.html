<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
</head>
<body>
<h1 id="методическое-пособие-для-самостоятельной-подготовки-к-практическим-занятиям-по-дисциплине-программирование">Методическое пособие для самостоятельной подготовки к практическим занятиям по дисциплине &quot;Программирование&quot;</h1>
<h2 id="содержание">Содержание</h2>
<p><a href="#introduce">Введение</a><br /><a href="#part1">1 Изображение блок-схемы алгоритма без ветвлений</a><br /><a href="#part1-1">1.1 Символы начала и конца программы</a><br /><a href="#part1-2">1.2 Операторный блок</a><br /><a href="#part1-3">1.3 Символ ввода-вывода данных</a><br /><a href="#part1-4">1.4 Комментарии</a><br /><a href="#part1-5">1.5 Общие рекомендации по оформлению блок-схем</a><br /><a href="#part1-6">1.6 Пример блок-схемы линейной программы</a><br /><a href="#part1-7">1.7 Задачи для самостоятельной подготовки</a><br /><a href="#part2">2 Изображение блок-схемы с ветвлениями</a><br /><a href="#part2-1">2.1 Условный оператор</a><br /><a href="#part2-2">2.2 Организация циклических процессов</a><br /><a href="#part2-2-1">2.2.1 Циклы с предусловием</a><br /><a href="#part2-2-2">2.2.2 Циклы с постусловием</a><br /><a href="#part2-3">2.3 Примеры блок-схем с ветвлениями</a><br /><a href="#part2-4">2.4 Задачи для самостоятельной подготовки</a><br /><a href="#part3">3 Операторы переходов</a><br /><a href="#part3-1">3.1 Оператор безусловного перехода</a><br /><a href="#part3-2">3.2 Операторы расширенного управления циклами</a><br /><a href="#part3-3">3.3 Примеры блок-схем с операторами перехода</a><br /><a href="#part3-4">3.4 Задачи для самостоятельной подготовки</a><br /><a href="#part4">4 Подпрограммы</a><br /><a href="#part4-1">4.1 Понятие предопределенной процедуры</a><br /><a href="#part4-2">4.2 Изображение процедур</a><br /><a href="#part4-3">4.3 Изображение функций</a><br /><a href="#part4-4">4.4 Примеры блок-схем с использованием подпрограмм</a><br /><a href="#part4-5">4.5 Задачи для самостоятельной подготовки</a><br /><a href="#conclude">Заключение</a></p>
<h2 id="introduce">Введение</h2>
<p>Данное методическое пособие предназначено для студентов направления 230100.62 &quot;Информатика и вычислительная техника&quot; А так же студентов других направлений при изучении дисциплин связанных с разработкой программ.</p>
<p>Целью пособия является ознакомление обучающихся с основами алгоритмизации и правилами оформления блок-схем.</p>
<p>Приведем некоторые определения.</p>
<p>Алгоритм - описание последовательности действий , строгое исполнение которых приводит к решению поставленной задачи за конечное число шагов. Для любого алгоритма характерны следующие свойства: дискретность, детерминированность. конечность, массовость и результативность.</p>
<p>Существую различные формы представления алгоритмов: словесный, формульно-словесный, графический, алгоритмический язык. Словесный способ представления несложен, но имеет ряд недостатков. Главный из которых состоит в том, что при таком способе допускается некоторая произвольность изложения и не существует четких стандартов описания. Сложные задачи с анализом условий, с повторяющимися действиями и возвратами к предыдущим пунктам трудно представляются в словесном и словесно-формульном виде. Наиболее наглядным является графический способ записи алгоритмов, одной из форм которого является блок-схема.</p>
<p>Блок-схемой называется графическое изображение логической структуры алгоритма, в котором каждый этап процесса обработки информации представляется в виде геометрических символов (блоков), имеющих определенную конфигурацию в зависимости от характера выполняемых операций.</p>
<p>Несмотря на часто кажущуюся студентам ненужность аппарата блок-схем, важно помнить, что блок-схема - это, прежде всего, четко оформленная идея.<br />Используемый в дискуссиях аргумент о нецелесообразности разработки схем алгоритмов в деятельности, не связанной с учебным процессом, не лишен смысла. Зачастую действительно быстрее написать и отладить программа &quot;с ходу&quot;, чем формально описывать алгоритм работы. Однако цель учебного процесса - научить студента ясному алгоритмическому мышлению. Именно эту задачу великолепно решают блок-схемы. Кроме того, существенным аргументом в пользу использования блок-схем является то, что, разрабатываемый алгоритм не привязан к синтаксису определенного языка.</p>
<p>Помните, что даже специалисты большую часть рабочего времени тратят на обдумывание способов решения поставленных перед ними задач. Только после грамотного анализа и оценки возможных вариантов реализации целесообразно приступать к написанию программного кода. Поэтому необходимо стремиться к достижению состояния предельно ясного осознания метода осуществления задуманного. Возможно, после приобретения способности разработки алгоритмов только посредством устного рассуждения и имеет смысл отказаться от составления блок-схем как повседневной практики. Однако, на этапе освоения азов программирования необходимо прибегать к данному аппарату хотя бы в целях дисциплинирования ума.</p>
<p>Следует обратить внимание на тот факт, что излагаемый материал подается с содержательной точки зрения и содержит ряд незначительных терминологических допущений. В частности, термин &quot;алгоритм&quot; нередко подменяется термином &quot;программа&quot;.</p>
<p>Пособие рекомендуется к ознакомлению в начале процесса изучения дисциплины &quot;Программирование&quot;.</p>
<h2 id="part1">1 Изображение блок-схемы алгоритма без ветвлений</h2>
<p>В данном разделе представлены общие сведения о составлении блок-схем алгоритмов и программ: требования к оформлению базовых символов, их соединений и содержимого, а также обязательным элементам блок-схемы.</p>
<h3 id="part1-1">1.1 Символы начала и конца программы</h3>
<p>Блок-схема любого алгоритма всегда начинается терминальным символом &quot;Начало&quot;, а заканчивается терминальным символом &quot;Конец&quot;. Примеры их изображения представлены на рисунке 1.1.</p>
<div class="figure">
<img src="static/pic111.PNG" alt="Рисунок 1.1 - Пример изображения терминальных символов" /><p class="caption">Рисунок 1.1 - Пример изображения терминальных символов</p>
</div>
<p>Данные элементы являются своеобразными точками входа и выхода из блок-схемы, поэтому символ &quot;Начало&quot; имеет только выходную линию, а символ &quot;Конец&quot; - входную.</p>
<h3 id="part1-2">1.2 Операторный символ</h3>
<p>Операторный символ (или символ процесса) явлется базовым элементом блок-схемы, который предназначен для отображения действий, совершаемых над данными. Текст символа может описывать как одну, так и несколько операций. Во втором случае допускается увеличение высоты символа. Пример изображения элемента представлен на рисунке 1.2.</p>
<div class="figure">
<img src="static/pic121.PNG" alt="Рисунок 1.2 - Пример использования операторного символа" /><p class="caption">Рисунок 1.2 - Пример использования операторного символа</p>
</div>
<p>На практике операторный символ чаще всего используется для описания процесса вычислений.</p>
<h3 id="part1-3">1.3 Символ ввода-вывода данных</h3>
<p>Для обозначения операции ввода-вывода данных используется символ данных, пример изображения которого приведен на рисунке 1.3.</p>
<div class="figure">
<img src="static/pic131.PNG" alt="Рисунок 1.3 - Пример использования символа данных" /><p class="caption">Рисунок 1.3 - Пример использования символа данных</p>
</div>
<p>Данный элемент применяется для указания выполнения операции как ввода данных пользователем, так и чтения данных из внешнего источника. Кроме того, символ позволяет отразить процесс вывода информации на носитель любой природы (экран, ВЗУ и т.д.). При этом природа обрабатываемых данных (числовая, текстовая, графическая и т.д. информация) не имеет значения.</p>
<h3 id="part1-4">1.4 Комментарии</h3>
<p>Зачастую размер символа блок-схема не позволяет отразить некоторые нюансы алгоритмы. В связи с этим особо важные с содержательной точки зрения элементы могут быть сопровождены комментариями. Дополнительная информация изображается на схеме в соответствии с представленным на рисунке 1.4 способом.</p>
<div class="figure">
<img src="static/pic141.PNG" alt="Рисунок 1.4 - Пример использования комментария" /><p class="caption">Рисунок 1.4 - Пример использования комментария</p>
</div>
<p>Следует помнить, что текст комментария приводится на русском языке, а сам символ распологается в наиболее удобном месте схемы, не перекрывая остальные элементы схемы. Если это не нарушает общего восприятия схемы, то рекомендуется помещать пояснения в непосредственной близости от комментируемых символов.</p>
<p>Кроме того, допускается заключать группу символов, к которой относится комментарий, в пунктирную рамку. Пример такого изображения представлен на рисунке 1.5.</p>
<div class="figure">
<img src="static/pic142.PNG" alt="Рисунок 1.5 - Пример использования комментария группы символов" /><p class="caption">Рисунок 1.5 - Пример использования комментария группы символов</p>
</div>
<h3 id="part1-5">1.5 Общие рекомендации по оформлению блок-схем</h3>
<p>При оформлении блок-схем рекомендуется придерживаться следующих правил.</p>
<ul>
<li>Несмотря на то, что ГОСТ не накладывает ограничений на содержимое символов, рекомендуется описывать команды на языке, близком к естественному. Так, действие по выводу значения переменной на экран может быть записано как &quot;writeln(X)&quot; или &quot;Вывести X&quot;. Второй вариант является более предпочтительным. Данная рекомендация связана с тем, что описание команд на языке, близком к конкретному zязыку программирования (ЯП) чревато путаницей: языки программирования имеют разную популярность и распространенность, зависящую от огромного числа факторов. Например, команда &lt;&gt; для подавляющего большинства неспециалистов в этом ЯП может оказаться незнакомой. Блок-схема - по своему назначению прежде всего универсальная структура, поэтому следует избегать ее связывания с конкретным ЯП.</li>
<li>Соединение элементов схемы выполняется посредством линий. Стандартным считается направление слева направо и сверху вниз. Для внесения ясности рекомендуется использовать стрелки, размещаемые на окончании линий.</li>
<li>Для всех символов за исключением условного входной считается верхняя или левая сторона, а выходной - нижняя или правая (при этом приоритет следует отдавать верхней и нижней сторонам).</li>
<li>По возможности следует избегать пересечения соединительных линий. В случае, когда разрыв линии позволяет оптимизировать графическое представление алгоритма, либо алгоритм является многостраничным, допускается использовать символ соединитель, изображаемый в виде круга с меткой . Соединитель в начале разрыва называется внешним соединителем, а соединитель в конце разрыва - внутренним соединителем. Пример данного действия представлен на рисунке 1.6.</li>
</ul>
<div class="figure">
<img src="static/pic151.PNG" alt="Рисунок 1.6 - Пример использования соединителя" /><p class="caption">Рисунок 1.6 - Пример использования соединителя</p>
</div>
<ul>
<li>При работе с соединителями следует также принимать во внимание перечисленные требования.
<ul>
<li>Необходимо обеспечивать уникальность используемой метки в пределах схемы (желательно - в пределах всего набора документации).</li>
<li>Допускается использовать несколько внешних соединителей с одной меткой, однако метки всех внутреннымх соединителей должны быть попарно различны.</li>
<li>Соединители рекомендуются к применению при переносе части схемы на другую страницу (при этом в комментарии следует указывать номер следующей страницы).</li>
</ul></li>
<li>При печати допускается изображение схем как в книжной, так и в альбомной ориентациях.</li>
<li>Если размер символа не позволяет включить в него минимум текста для описания его смысловой нагрузки, то допускается изложение части содержимого (или всего текста) в символе комментария.</li>
<li>Если это необходимо, допускается присваивание символу уникального идентификатора, который размещается слева и сверху от соответствующего блока. Данный идентификатор может быть использован в сопроводительном тексте для явной ссылки на блок. Пример изображения идентификатора представлен на рисунке 1.7.</li>
</ul>
<div class="figure">
<img src="static/pic152.PNG" alt="Рисунок 1.7 - Пример использования идентификатора" /><p class="caption">Рисунок 1.7 - Пример использования идентификатора</p>
</div>
<p>Типовые ошибки, как правило, связаны с нарушением следующих правил.</p>
<!--TODO: Перечислить типовые ошибки-->

<ul>
<li>Ширина всех блоков схемы должна быть одинаковой.</li>
<li>При соединении блоков следует использовать только вертикальные и горизонтальные линии потоков.</li>
<li>Горизонтальные потоки, имеющие направление справа налево, и вертикальные потоки, имеющие направление снизу вверх, должны быть обязательно помечены стрелками.</li>
<li>Линии потоков должны быть параллельны линиям внешней рамки или границам листа</li>
<li>Текст символов и коментариев должен записываться слева направо и сверху вниз независимо от направления потоков данных или управления.</li>
<li>Как правило, каждый символ имеет один вход и один выход. Исключение составляют:
<ul>
<li>терминальные символы (у операции &quot;начало&quot; нет входа, у операции &quot;конец&quot; нет выхода),</li>
<li>символы решения (один вход и несколько выходов).</li>
</ul></li>
</ul>
<h3 id="part1-6">1.6 Пример блок-схемы линейной программы</h3>
<p>По структуре алгоритмы разделяют на линейные, разветвляющиеся и циклические.</p>
<p>Линейными называют алгоритмы, в которых операции выполняются последовательно одна за другой, в естественном и единственном порядке следования.. Как правило, алгоритмы линейной структуры состоят из трех частей: ввод исходных данных, вычисления результатов по формулам, вывод значений результатов. Это самые простые алгоритмы, которые являются составной частью любого алгоритмического процесса.</p>
<p>Пусть требуется реализовать программу для подсчета суммы, разности и произведения двух заданных чисел.</p>
<p>Блок-схема алгоритма решения предлагаемой задачи изображена на рисунке 1.8.</p>
<div class="figure">
<img src="static/pic161.PNG" alt="Рисунок 1.8 - Блок-схема алгоритма для нахождения суммы, разности и произведения двух заданных чисел" /><p class="caption">Рисунок 1.8 - Блок-схема алгоритма для нахождения суммы, разности и произведения двух заданных чисел</p>
</div>
<p>Тогда программа, написанная в соответствии с представленной на рисунке схемой, будет выглядеть следующим образом.</p>
<p>На языке программирования Pascal:</p>
<pre class="sourceCode Pascal" id="ex11P"><code class="sourceCode pascal"><span class="kw">var</span> a, b, sum, sub, mul: <span class="dt">integer</span>;
<span class="kw">begin</span>
  <span class="kw">read</span>(a, b);
  sum := a + b;
  <span class="kw">write</span>(sum, <span class="st">&#39; &#39;</span>);
  sub := a - b;
  <span class="kw">write</span>(sub, <span class="st">&#39; &#39;</span>);
  mul := a * b;
  <span class="kw">write</span>(mul);
<span class="kw">end</span>.</code></pre>
<p>На языке программирования C:</p>
<pre class="sourceCode C" id="ex11C"><code class="sourceCode c"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="dt">int</span> main() {
    <span class="dt">int</span> a, b;
    scanf(<span class="st">&quot;%d %d&quot;</span>, &amp;a, &amp;b);
    <span class="dt">int</span> sum = a + b;
    printf(<span class="st">&quot;Sum = %d</span><span class="ch">\n</span><span class="st">&quot;</span>, sum);
    <span class="dt">int</span> sub = a - b;
    printf(<span class="st">&quot;Sub = %d</span><span class="ch">\n</span><span class="st">&quot;</span>, sub);
    <span class="dt">int</span> mul = a * b;
    printf(<span class="st">&quot;Mul = %d</span><span class="ch">\n</span><span class="st">&quot;</span>, mul);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h3 id="part1-7">1.7 Задачи для самостоятельной подготовки</h3>
<p>Изобразите блок-схемы алгоритмов для решения предлагаемых задач.</p>
<ol style="list-style-type: decimal">
<li>Определите последнюю цифру заданного числа.</li>
<li>Определите сколько десятков в заданном числе.</li>
<li>Найдите сумму цифр трехзначного числа.</li>
<li>Найдите следующее четное за заданным число.</li>
<li>Найдите абсолютное значение заданного числа.</li>
<li>Определите площадь прямоугольника по длинам его сторон.</li>
<li>Определите площадь треугольника по длинам его сторон.</li>
<li>Определите объем шара с радиусом R.</li>
<li>Найдите середину отрезка, заданного координатами своих концов.</li>
<li>Найдите координаты точки пересечения двух прямых.</li>
</ol>
<h2 id="part2">2 Изображение блок-схемы с ветвлениями</h2>
<p>В данном разделе рассматриваются вопросы, связанные с оформлением ветвящихся процессов и циклических конструкций.</p>
<h3 id="part2-1">2.1 Условный оператор</h3>
<p>Подавляющее большинство алгоритмов имеет структуру, отличную от линейной. На практике часто возникает необходимость проведения анализа исходных данных или промежуточных результатов вычислений с целью определения дальнейшего порядка выполнения вычислительного процесса. Алгоритмы, в которых в зависимости от выполнения некоторого логического условия происходит разветвление вычислений по одному из нескольких возможных направлений, называют разветвляющимися. Подобные алгоритмы предусматривают выбор одного из альтернативных путей продолжения вычислений. Каждое возможное направление вычислений называется ветвью. Логическое условие называют простым, если разветвляющийся процесс имеет две ветви, и сложным, если процесс разветвляется на три и более ветви. Для выбора дальнейшей цепочки операций предназначен символ решения. Пример изображения данного элемента представлен на рисунке 2.1.</p>
<div class="figure">
<img src="static/pic211.PNG" alt="Рисунок 2.1 - Пример изображения символа решения" /><p class="caption">Рисунок 2.1 - Пример изображения символа решения</p>
</div>
<p>Приведенный выше символ эквивалентен характерному практически для всех языков программирования условному оператору.</p>
<p>При использовании символа необходимо придерживаться следующих правил.</p>
<ul>
<li>Символ может иметь один и только один вход и ряд взаимоисключающих (альтернативных) выходов.</li>
<li>Текст символа должен содержать описание какого-либо логического условия или действия, предполагающего сравнение элемента с набором допустимых значений. Размещение описания операций внутри символа не допускается.</li>
<li>Входным считается верхний угол блока, а выходными - остальные.</li>
<li>Выходящие ветви должны сопровождаться текстом, однозначно определяющим выполняемые в дальнейшем операции (выбранный путь). В случае, когда текст символа содержит условие, разрешается использовать пары индентификаторов вида &quot;Да&quot;-&quot;Нет&quot;, &quot;1&quot;-&quot;0&quot;, &quot;Истина&quot;-&quot;Ложь&quot;, &quot;True&quot;-&quot;False&quot; и т.д.</li>
</ul>
<p>Как было сказано ранее, символ решения может иметь более двух выходов. В этом случае допускается наличие как нескольких выходящих ветвей, так и одной ветви, разделяющейся в дальнейшем. Все прочие рекомендации по оформлению символа остаются актуальными. Пример изображения символа решения с группой выходов представлен на рисунке 2.2.</p>
<div class="figure">
<img src="static/pic212.PNG" alt="Рисунок 2.2 - Пример изображения символа решения с группой выходов" /><p class="caption">Рисунок 2.2 - Пример изображения символа решения с группой выходов</p>
</div>
<p>Следует обратить внимание, на тот факт, что при наличии ровно двух альтернатив рекомендуется в целях внесения большей ясности избегать варианта оформления с единственным разделяющимся выходом.</p>
<h3 id="part2-2">2.2 Организация циклических процессов</h3>
<p>Часто при решении задач приходится многократно выполнять одни и те же операции для различных значений входящих величин. Такие многократно повторяемые участки вычислительного процесса называются алгоритмами циклической структуры, или циклами. Использование циклов позволяет существенно сократить объем схемы алгоритма и длину соответствующей ей программы. Группы повторяющихся вычислений называют тело цикла. Специально изменяемый по заданному закону параметр, входящий в тело цикла, называется переменной цикла. Переменная цикла используется для подготовки очередного повторения цикла и отслеживания условий его окончания.</p>
<p>В качестве переменной цикла используют любые переменные, индексы массивов, аргументы вычисляемых функций и т.д.</p>
<p>Для правильной организации цикла необходимо:</p>
<ul>
<li>задать перед циклом начальное значение переменной, изменяющейся в цикле;</li>
<li>выполнить тело цикла;</li>
<li>изменить переменную перед каждым новым повторением цикла;</li>
<li>проверить условие окончания или повторения цикла.</li>
</ul>
<p>Циклические алгоритмы, в которых число повторений заранее известно из исходных данных или определено в ходе решения задачи, называют детерминированными, если число повторений тела цикла заранее неизвестно, а зависит от значений параметров, участвующих в вычислениях цикл называют итерационным.</p>
<p>Для отображения циклических процессов используется символ, состоящий из двух частей, определяющий начало и конец цикла (рисунок 2.3). Обе части символа имеют один и тот же идентификатор. Условия для инициализации, завершения могут помещаться внутри символа в начале или в конце. В зависимости от расположения операции проверки условия циклы могут быть организованы как циклы с предусловием или с постусловием.</p>
<div class="figure">
<img src="static/pic221.PNG" alt="Рисунок 2.3 - Пример изображения символа цикла" /><p class="caption">Рисунок 2.3 - Пример изображения символа цикла</p>
</div>
<h4 id="part2-2-1">2.2.1 Циклы с предусловием</h4>
<p>Если в цикле с предусловием входящие в тело цикла команды могут не выполняться ни разу (если начальное значение параметра цикла удовлетворяет условию выхода из цикла, рисунок 2.4)</p>
<div class="figure">
<img src="static/pic222.PNG" alt="Рисунок 2.4 - Пример изображения цикла с предусловием" /><p class="caption">Рисунок 2.4 - Пример изображения цикла с предусловием</p>
</div>
<h4 id="part2-2-2">2.2.2 Циклы с постусловием</h4>
<p>В цикле с постусловием - выполняются как минимум один раз (даже если начальное значение параметра цикла удовлетворяет условию выхода из него, рисунок 2.5).</p>
<div class="figure">
<img src="static/pic223.PNG" alt="Рисунок 2.5 - Пример изображения цикла с постусловием" /><p class="caption">Рисунок 2.5 - Пример изображения цикла с постусловием</p>
</div>
<p>Операция по модификации переменой цикла может быть определена как в теле цикла, так и в символе конца. Недопустима модификация переменной цикла в символе начала цикла.</p>
<h3 id="part2-3">2.3 Примеры блок-схем с ветвлениями</h3>
<p>Пусть требуется реализовать программу для определения знака заданного числа.</p>
<p>Блок-схема алгоритма для решения предлагаемой задачи представлена на рисунке 2.6.</p>
<div class="figure">
<img src="static/pic231.PNG" alt="Рисунок 2.6 - Блок-схема алгоритма определения знака числа" /><p class="caption">Рисунок 2.6 - Блок-схема алгоритма определения знака числа</p>
</div>
<p>Решение задачи на языке Pascal представлено ниже.</p>
<pre class="sourceCode Pascal" id="ex21P"><code class="sourceCode pascal"><span class="kw">var</span> x: <span class="dt">real</span>;
<span class="kw">begin</span>
  readln(x);
  <span class="kw">if</span> (x &lt; <span class="dv">0</span>) <span class="kw">then</span>
    writeln(<span class="st">&#39;Negative&#39;</span>)
  <span class="kw">else</span>      
    writeln(<span class="st">&#39;Positive&#39;</span>);
<span class="kw">end</span>.</code></pre>
<p>На языке программирования C:</p>
<pre class="sourceCode C" id="ex21С"><code class="sourceCode c"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="dt">int</span> main() {
    <span class="dt">float</span> x;
    scanf(<span class="st">&quot;%f&quot;</span>, &amp;x);
    <span class="kw">if</span>(x &lt; <span class="dv">0</span>)   
        printf(<span class="st">&quot;Negative</span><span class="ch">\n</span><span class="st">&quot;</span>);
    <span class="kw">else</span> 
        printf(<span class="st">&quot;Positive</span><span class="ch">\n</span><span class="st">&quot;</span>);
}</code></pre>
<p>Пусть требуется реализовать программу для определения числа нулевых элементов в заданной матрице.</p>
<p>Блок-схема алгоритма решения предлагаемой задачи представлена на рисунке 2.7.</p>
<div class="figure">
<img src="static/pic232.PNG" alt="Рисунок 2.7 - Блок-схема алгоритма вычисления суммы элементов" /><p class="caption">Рисунок 2.7 - Блок-схема алгоритма вычисления суммы элементов</p>
</div>
<p>Эквивалентная программа на языке Pascal:</p>
<pre class="sourceCode Pascal" id="ex22P"><code class="sourceCode pascal"><span class="kw">var</span> n, m, i, j, s: <span class="dt">integer</span>;
    a: <span class="kw">array</span> [<span class="dv">1</span>..<span class="dv">100</span>, <span class="dv">1</span>..<span class="dv">100</span>] <span class="kw">of</span> <span class="dt">integer</span>;
<span class="kw">begin</span>
  <span class="kw">read</span>(n, m);
  s := <span class="dv">0</span>;
  writeln(<span class="st">&#39;Input matrix  &#39;</span>, n, <span class="st">&#39; to &#39;</span>, m ,<span class="st">&#39; elements&#39;</span>);
  <span class="kw">for</span> i := <span class="dv">1</span> <span class="kw">to</span> n <span class="kw">do</span>
    <span class="kw">for</span> j := <span class="dv">1</span> <span class="kw">to</span> m <span class="kw">do</span>
      <span class="kw">begin</span>
      <span class="kw">read</span>(a[i, j]);
      <span class="kw">if</span> a[i, j] = <span class="dv">0</span> <span class="kw">then</span> inc(s);
      <span class="kw">end</span>;
  writeln(<span class="st">&#39;Number of 0 elements &#39;</span>, s);
  readln;
<span class="kw">end</span>.</code></pre>
<p>На языке программирования C:</p>
<pre class="sourceCode C" id="ex22С"><code class="sourceCode c"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="dt">int</span> main() {
    <span class="dt">int</span> n, m, s = <span class="dv">0</span>;
    <span class="dt">int</span> a[<span class="dv">100</span>][<span class="dv">100</span>];
    scanf(<span class="st">&quot;%d %d&quot;</span>, &amp;n, &amp;m);
    printf(<span class="st">&quot;Input matrix %d  to  %d elements&quot;</span>, n, m);
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++)
        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; m; j++) {
            scanf(<span class="st">&quot;%d&quot;</span>, &amp;a[i][j]);
            <span class="kw">if</span>(a[i][j] == <span class="dv">0</span>) 
                s++;
        }
    printf(<span class="st">&quot;Number of 0 elements %d&quot;</span>, s);
}</code></pre>
<p>Пусть требуется реализовать программу для вычисления суммы элементов заданного набора чисел. Мощность набора неизвестна заранее, элементы вводятся в программу поочередно, последовательность заканчивается числом &quot;0&quot;.</p>
<p>Блок-схема алгоритма решения предлагаемой задачи представлена на рисунке 2.8.</p>
<div class="figure">
<img src="static/pic233.PNG" alt="Рисунок 2.8 - Блок-схема алгоритма вычисления суммы элементов" /><p class="caption">Рисунок 2.8 - Блок-схема алгоритма вычисления суммы элементов</p>
</div>
<p>Программная реализация на языке Pascal:</p>
<pre class="sourceCode Pascal" id="ex23P"><code class="sourceCode pascal"><span class="kw">var</span> a, s: <span class="dt">integer</span>;
<span class="kw">begin</span>
  s := <span class="dv">0</span>;
  <span class="kw">repeat</span>
    <span class="kw">read</span>(a);
    s := s + a;
  <span class="kw">until</span> a = <span class="dv">0</span>;
  writeln(<span class="st">&#39;Summa of elements &#39;</span>, s);
  readln;
<span class="kw">end</span>.</code></pre>
<p>На языке программирования C:</p>
<pre class="sourceCode C" id="ex23С"><code class="sourceCode c"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="dt">int</span> main() {
    <span class="dt">int</span> a, s = <span class="dv">0</span>;
    <span class="kw">do</span> {
        scanf(<span class="st">&quot;%d&quot;</span>, &amp;a);
        s = s + a;
    }
    <span class="kw">while</span> (a != <span class="dv">0</span>); 
    printf(<span class="st">&quot;Summa of elements %d&quot;</span>, s);
}</code></pre>
<h3 id="part2-4">2.4 Задачи для самостоятельной подготовки</h3>
<p>Изобразите блок-схемы алгоритмов для решения предлагаемых задач.</p>
<ol style="list-style-type: decimal">
<li>Выберите максимальное из двух заданных чисел.</li>
<li>По заданным параметрам a, b и с найдите корни квадратного уравнения.</li>
<li>Упорядочите три заданных числа по возрастанию.</li>
<li>Определите, является ли заданный год високосным.</li>
<li>Определите, сколько дней прошло между двумя датами.</li>
<li>Определите, какое число будет послезавтра.</li>
<li>Определите, принадлежит ли точка треугольнику, заданному координатами вершин.</li>
<li>Определите, расположен ли один прямоугольник внутри другого. Прямоугольники задаются координатами верхнего левого и правого нижнего углов.</li>
<li>Определите что больше: а в степени b или b в степени а?</li>
<li>Определите, может ли существовать треугольник с заданными длинами сторон.</li>
<li>Найдите сумму цифр заданного числа.</li>
<li>Найдите произведение цифр заданного числа.</li>
<li>Подсчитайте количество натуральных делителей заданного числа.</li>
<li>В заданном массиве найдите сумму максимального и минимального элементов.</li>
<li>В заданном массиве найдите k-ую статистику.</li>
<li>В заданном массиве подсчитайте сумму чисел, расположенных на нечетных позициях.</li>
<li>Реверсируйте заданную строчку.</li>
<li>Подсчитайте количество четных и нечетных элементов в массиве.</li>
<li>Найдите такие индексы i и j, что произведение соответствующих элементов массива минимально.</li>
<li>Подсчитайте сколько различных чисел присутствует в заданном наборе.</li>
<li>Определите, является ли заданный массив монотонным.</li>
<li>Проверьте, является ли заданное число простым.</li>
<li>Проверьте, является ли заданное число совершенным.</li>
<li>Проверьте, является ли строка палиндромом.</li>
<li>Найдите минимальный период в строке.</li>
<li>Определите, сколько символов необходимо дописать к строке с начала и с конца, чтобы она стала палиндромом.</li>
<li>Определите, является ли одна строка подстрокой другой.</li>
<li>Найдите максимальный элемент в заданной матрице.</li>
<li>Проверьте, является ли заданная двоичная матрица транзитивной.</li>
<li>Определите, имеются ли в заданной матрице одинаковые строки.</li>
<li>Найдите, если это возможно, произведение двух заданных матриц.</li>
<li>Найдите определитель матрицы 4x4.</li>
<li>Подсчитайте сумму элементов на диагоналях двумерного массива.</li>
<li>Определите что больше: а в степени b или b в степени а? Не используйте возведение в степень.</li>
<li>Определите, является ли заданный набор чисел монотонным. Не используйте массивы.</li>
<li>Найдите такие индексы i и j, что произведение соответствующих элементов массива минимально. Не используйте вложенные циклы.</li>
<li>Найдите минимальный период в массиве. Не используйте вложенные циклы.</li>
<li>Определите, сколько символов необходимо дописать к строке с начала и с конца, чтобы она стала палиндромом. Не используйте вложенные циклы.</li>
<li>Определите, какая из трехсимвольных подстрок встречается в заданной строке чаще всего.</li>
<li>Подсчитайте сумму элементов на диагоналях трехмерного массива.</li>
</ol>
<h2 id="part3">3 Операторы переходов</h2>
<p>В данном разделе рассматриваются вопросы, связанные с оформлением операторов управления потоком команд.</p>
<h3 id="part3-1">3.1 Оператор безусловного перехода</h3>
<p>Безусловным принято называть принудительный переход к следующей выполняемой инструкции, отличной от очередной по порядку. В большинстве языков программирования, предоставляющих программисту возможность организации безусловного перехода, для данной цели используется оператор goto.</p>
<p>Необходимо отметить, что среди профессионалов в области компьютерных технологий бытует совершенно справедливое мнение о вредности оператора безусловного перехода. В первую очередь данная позиция обосновывается тезисом о нарушении парадигмы структурного программирования. Для подробного ознакомления с вопросом рекомендуется обратиться к статье Э. Дейкстры &quot;Go To Statement Considered Harmful&quot; и теореме Бема-Якопини. Общая рекомендация такова: если в сложившихся обстоятельствах возможно обойтись без применения безусловного перехода - откажитесь от его использования.</p>
<p>В тех же случаях, когда его применение по каким-либо причинам неизбежно, следует помнить о том, что этот оператор влияет только на поток управления и никоим образом не взаимодействует с данными. Следовательно, блок-схема не может содержать специального символа, отражающего наличие принудительного перехода. Для этих целей предназначены линии соединений.</p>
<h3 id="part3-2">3.2 Операторы расширенного управления циклами</h3>
<p>Типичными инструкциями расширенного управления циклами являются операторы break и continue. Первый позволяет аварийно завершить выполнение цикла вне зависимости от значения условия завершения, второй предназначен для принудительного перехода к следующей итерации цикла.</p>
<p>Аналогичным с безусловным переходом образом данные операторы являются исключительно управляющими, поэтому на блок-схеме отображаются с помощью соединительных линий. В первом случае линию следует объединять с выходом символа завершения цикла, во втором - с входом символа изменения значения управляющих переменных перед блоком завршения цикла.</p>
<h3 id="part3-3">3.3 Примеры блок-схем с операторами перехода</h3>
<p>Пусть требуется реализовать программу для определения наличия некоторого числа K в заданном массиве из N элементов.</p>
<p>Блок-схема алгоритма для решения предлагаемой задачи представлена на рисунке 3.1.</p>
<div class="figure">
<img src="static/pic331.PNG" alt="Рисунок 3.1 - Блок-схема алгоритма определения наличия числа в наборе" /><p class="caption">Рисунок 3.1 - Блок-схема алгоритма определения наличия числа в наборе</p>
</div>
<p>Эквивалентная блок-схеме программа на языке Pascal:</p>
<pre class="sourceCode Pascal" id="ex31P"><code class="sourceCode pascal"><span class="kw">var</span> n, k, x, i: <span class="dt">integer</span>;
    flag: <span class="dt">boolean</span>;
<span class="kw">begin</span>
  <span class="kw">read</span>(n, k);
  flag := <span class="kw">false</span>;
  <span class="kw">for</span> i := <span class="dv">1</span> <span class="kw">to</span> n <span class="kw">do</span>
    <span class="kw">begin</span>
    <span class="kw">read</span>(x);
    <span class="kw">if</span> (x = k) <span class="kw">then</span>
      <span class="kw">begin</span>
      flag := <span class="kw">true</span>;
      writeln(<span class="st">&#39;Found!&#39;</span>);
      <span class="kw">break</span>;
      <span class="kw">end</span>;
    <span class="kw">end</span>;
  <span class="kw">if</span> (<span class="kw">not</span> flag) <span class="kw">then</span>
    writeln(<span class="st">&#39;Not found!&#39;</span>);
<span class="kw">end</span>.</code></pre>
<p>На языке программирования C:</p>
<pre class="sourceCode C" id="ex31С"><code class="sourceCode c"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="dt">int</span> main() {
    <span class="dt">int</span> n, k, x, flag = <span class="dv">0</span>;
    scanf(<span class="st">&quot;%d %d&quot;</span>, &amp;n, &amp;k);
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
        scanf(<span class="st">&quot;%d&quot;</span>, &amp;x);
        <span class="kw">if</span>(x == k) {
            flag = <span class="dv">1</span>;
            printf(<span class="st">&quot;Found!</span><span class="ch">\n</span><span class="st">&quot;</span>);
            <span class="kw">break</span>;
        }
    }
    <span class="kw">if</span>(flag == <span class="dv">0</span>)
        printf(<span class="st">&quot;Not found!</span><span class="ch">\n</span><span class="st">&quot;</span>);
}</code></pre>
<p>Пусть требуется реализовать программу для подсчета числа пар одинаковых элементов в массиве из N (известно, что N не превосходит 100) величин.</p>
<p>Блок-схема алгоритма решения предлагаемой задачи представлена на рисунке 3.2.</p>
<div class="figure">
<img src="static/pic332.PNG" alt="Рисунок 3.2 - Блок-схема алгоритма подсчета числа одинаковых пар" /><p class="caption">Рисунок 3.2 - Блок-схема алгоритма подсчета числа одинаковых пар</p>
</div>
<p>Программа на языке Pascal:</p>
<pre class="sourceCode Pascal" id="ex32P"><code class="sourceCode pascal"><span class="kw">var</span> n, i, j, cnt: <span class="dt">integer</span>;
    a: <span class="kw">array</span> [<span class="dv">1</span>..<span class="dv">100</span>] <span class="kw">of</span> <span class="dt">integer</span>;
<span class="kw">begin</span>
  <span class="kw">read</span>(n);
  <span class="kw">for</span> i := <span class="dv">1</span> <span class="kw">to</span> n <span class="kw">do</span>
    <span class="kw">read</span>(a[i]);
  cnt := <span class="dv">0</span>;
  <span class="kw">for</span> i := <span class="dv">1</span> <span class="kw">to</span> n <span class="kw">do</span>
    <span class="kw">for</span> j := <span class="dv">1</span> <span class="kw">to</span> n <span class="kw">do</span>
      <span class="kw">begin</span>
      <span class="kw">if</span> (i = j) <span class="kw">then</span>
        <span class="kw">continue</span>;
      <span class="kw">if</span> (a[i] = a[j]) <span class="kw">then</span>
        inc(cnt);  
      <span class="kw">end</span>;
  writeln(<span class="st">&#39;Number of pairs is &#39;</span>, cnt <span class="kw">div</span> <span class="dv">2</span>);    
<span class="kw">end</span>.</code></pre>
<p>На языке программирования C:</p>
<pre class="sourceCode C" id="ex32С"><code class="sourceCode c"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="dt">int</span> main() {
    <span class="dt">int</span> n, cnt = <span class="dv">0</span>;
    scanf(<span class="st">&quot;%d&quot;</span>, &amp;n);
    <span class="dt">int</span> a[n];
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++)
        scanf(<span class="st">&quot;%d&quot;</span>, &amp;a[i]);
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++)
        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++) {
            <span class="kw">if</span>(i == j)
                <span class="kw">continue</span>;
            <span class="kw">if</span>(a[i] == a[j])
                cnt++;
        }
    printf(<span class="st">&quot;Number of pairs is %d</span><span class="ch">\n</span><span class="st">&quot;</span>, cnt / <span class="dv">2</span>);
}</code></pre>
<h3 id="part3-4">3.4 Задачи для самостоятельной подготовки</h3>
<p>Изобразите блок-схемы алгоритмов для решения предлагаемых задач. Используйте операторы расширенного управления циклами.</p>
<ol style="list-style-type: decimal">
<li>Определите, присутствует ли в наборе чисел хотя бы одно отрицательное.</li>
<li>Определите, присутствует ли в заданном наборе чисел степень двойки.</li>
<li>Определите, лежат ли все точки из заданного набора на одной прямой.</li>
<li>Определите, присутствует ли в заданной строке подстрока из трех одинаковых букв.</li>
<li>Определите, является ли заданный массив строк упорядоченным.</li>
<li>Определите, является ли заданный массив знакочередующимся.</li>
<li>Подсчитайте количество строк в заданной матрице, таких, что в них есть хотя бы один нулевой элемент.</li>
<li>Найдите такое наименьшее K, что сумма первых K чисел заданного набора строго больше S.</li>
<li>Найдите первые сто простых чисел.</li>
<li>Найдите первые пять совершенных чисел.</li>
</ol>
<h2 id="part4">4 Подпрограммы</h2>
<p>В данном разделе приводятся рекомендации по оформлению составных частей программы - процедур и функций.</p>
<h3 id="part4-1">4.1 Понятие предопределенной процедуры</h3>
<p>Оформление блок-схемы сколь-нибудь больших алгоритмов практически невозможно без оперирования предопределенными процессами - последовательностями операций, определенных в другом месте (модуле, подпрограмме и т.д.). Символ предопределенного процесса изображен на рисунке 4.1.</p>
<div class="figure">
<img src="static/pic411.PNG" alt="Рисунок 4.1 - Пример изображения символа предопределенного процесса" /><p class="caption">Рисунок 4.1 - Пример изображения символа предопределенного процесса</p>
</div>
<p>Текст символа должен содержать текстовую метку (идентификатор), позволяющую однозначно идентифицировать набор инструкций, на который осуществляется ссылка. Если ссылка выполняется на отсутствующий в документации процесс, то рекомендуется явно указывать данный факт в комментариях. В остальном правила оформления данного символа не отличаются от правил оформления символа процесса.</p>
<p>Необходимо отметить, что применение рассматриваемого блока делает возможным декомпозицию разрабатываемого алгоритма на процедуры и функции.</p>
<h3 id="part4-2">4.2 Изображение процедур</h3>
<p>Вызов процедуры из произвольного места алгоритма рекомендуется оформлять изображенным на рисунке 4.2 образом.</p>
<div class="figure">
<img src="static/pic421.PNG" alt="Рисунок 4.2 - Пример изображения вызова процедуры" /><p class="caption">Рисунок 4.2 - Пример изображения вызова процедуры</p>
</div>
<p>Следует обратить внимание на тот факт, что при вызове после идентификатора необходимо указывать передаваемые параметры. Тело процедуры рекомендуется оформлять согласно приведенному на рисунке 4.3 способу.</p>
<div class="figure">
<img src="static/pic422.PNG" alt="Рисунок 4.3 - Пример изображения тела процедуры" /><p class="caption">Рисунок 4.3 - Пример изображения тела процедуры</p>
</div>
<p>Терминальные символы описания предопределенного процесса вместо надписей &quot;Начало&quot; и &quot;конец&quot; содержат присвоенную набору действий текстовую метку. В следующем за терминальным символом блоком ввода-вывода через запятую перечисляются параметры процедуры, причем в качестве имен применяются используемые в описании идентификаторы. В комментариях к символу ввода-вывода следует описать назначение принимаемых параметров и способ их передачи (по значению или по адресу).</p>
<h3 id="part4-3">4.3 Изображение функций</h3>
<p>Вызов функции из произвольного места алгоритма оформляется аналогичным образом, за тем исключением, что возвращаемое значение может быть присвоено некоторому идентификатору. Пример вызова функции представлен на рисунке 4.4.</p>
<div class="figure">
<img src="static/pic431.PNG" alt="Рисунок 4.4 - Пример изображения вызова функции" /><p class="caption">Рисунок 4.4 - Пример изображения вызова функции</p>
</div>
<p>Точно таким же образом при вызове функции после идентификатора необходимо указывать передаваемые параметры. Тело функции оформляется согласно приведенному на рисунке 4.5 способу.</p>
<div class="figure">
<img src="static/pic432.PNG" alt="Рисунок 4.5 - Пример изображения тела функции" /><p class="caption">Рисунок 4.5 - Пример изображения тела функции</p>
</div>
<p>Все перечисленные в предыдущем разделе положения об оформлении тела процесса остаются актуальными. Кроме того, перед завершающим терминальным символом необходимо явным образом указать возвращаемое функцией значение. В случае инвариантности допускается изображение нескольких символов с указанием возвращаемого значения. Однако структура предопределенного процесса должна быть выстроена таким образом, чтобы для любых входных данных происходило обращение ровно к одному возвращающему блоку ввода-вывода.</p>
<h3 id="part4-4">4.4 Примеры блок-схем с использованием подпрограмм</h3>
<p>Пусть требуется реализовать программу для упорядочивания элементов массива размерности N.</p>
<p>Блок-схема алгоритма для решения предлагаемой задачи представлена на рисунке 4.6.</p>
<div class="figure">
<img src="static/pic441.PNG" alt="Рисунок 4.6 - Блок-схема алгоритма сортировки массива" /><p class="caption">Рисунок 4.6 - Блок-схема алгоритма сортировки массива</p>
</div>
<p>В работе алгоритма используются предопределенные процессы &quot;Сортировка&quot; и &quot;Больше&quot;, блок-схемы которых изображены на рисунке 4.7 и 4.8 соответственно.</p>
<div class="figure">
<img src="static/pic443.PNG" alt="Рисунок 4.7 - Блок-схема предопределенного процесса &quot;Сортировка&quot;" /><p class="caption">Рисунок 4.7 - Блок-схема предопределенного процесса &quot;Сортировка&quot;</p>
</div>
<div class="figure">
<img src="static/pic442.PNG" alt="Рисунок 4.8 - Блок-схема предопределенного процессе &quot;Больше&quot;" /><p class="caption">Рисунок 4.8 - Блок-схема предопределенного процессе &quot;Больше&quot;</p>
</div>
<p>Наиболее важным элементом схемы на рисунке 4.7 является функция &quot;Деление&quot;. Алгоритм реализации этой подпрограммы приведен на рисунке 4.9.</p>
<div class="figure">
<img src="static/pic444.PNG" alt="Рисунок 4.9 - Блок-схема предопределенного процессе &quot;Деление&quot;" /><p class="caption">Рисунок 4.9 - Блок-схема предопределенного процессе &quot;Деление&quot;</p>
</div>
<p>Для обмена пары элементов местами используется процесс &quot;Обмен&quot;, схема которого представлена на рисунке 4.10.</p>
<div class="figure">
<img src="static/pic445.PNG" alt="Рисунок 4.10 - Блок-схема предопределенного процессе &quot;Обмен&quot;" /><p class="caption">Рисунок 4.10 - Блок-схема предопределенного процессе &quot;Обмен&quot;</p>
</div>
<p>Нетрудно заметить, что решение поставленной задачи основывается на рекурсивном алгоритмы быстрой сортировки. Код эквивалентной программы на языке Pascal может выглядеть следующим образом.</p>
<pre class="sourceCode Pascal" id="ex41P"><code class="sourceCode pascal"><span class="kw">const</span> maxsize = <span class="dv">1000</span>;
<span class="kw">type</span> arrint = <span class="kw">array</span> [<span class="dv">1</span>..maxsize] <span class="kw">of</span> <span class="dt">integer</span>;
     func = <span class="kw">function</span>(a, b: <span class="dt">integer</span>): <span class="dt">boolean</span>;
<span class="kw">var</span> n, i: <span class="dt">integer</span>;
    a: arrint;

<span class="kw">procedure</span> swap(<span class="kw">var</span> a, b: <span class="dt">integer</span>);
<span class="kw">var</span> c: <span class="dt">integer</span>;
<span class="kw">begin</span>
  c := a;
  a := b;
  b := c;
<span class="kw">end</span>;

<span class="kw">function</span> gr(a, b: <span class="dt">integer</span>): <span class="dt">boolean</span>; far;
<span class="kw">begin</span>
  <span class="kw">if</span> (a &gt; b) <span class="kw">then</span>
    gr := <span class="kw">true</span>
    <span class="kw">else</span>
    gr := <span class="kw">false</span>;
<span class="kw">end</span>;

<span class="kw">function</span> partition(<span class="kw">var</span> a: arrint; l, r: <span class="dt">integer</span>; cmp: func): <span class="dt">integer</span>;
<span class="kw">var</span> i, p: <span class="dt">integer</span>;
<span class="kw">begin</span>
  p := l;
  <span class="kw">for</span> i := l <span class="kw">to</span> r - <span class="dv">1</span> <span class="kw">do</span>
     <span class="kw">if</span> (cmp(a[i], a[r])) <span class="kw">then</span>
       <span class="kw">begin</span>
       swap(a[i], a[p]);
       p := p + <span class="dv">1</span>;
       <span class="kw">end</span>;
  swap(a[r], a[p]);
  partition := p;
<span class="kw">end</span>;

<span class="kw">procedure</span> sort(<span class="kw">var</span> a: arrint; l, r: <span class="dt">integer</span>; cmp: func);
<span class="kw">var</span> q: <span class="dt">integer</span>;
<span class="kw">begin</span>
  <span class="kw">if</span> (l &lt; r) <span class="kw">then</span>
    <span class="kw">begin</span>
    q := partition(a, l, r, cmp);
    sort(a, l, q - <span class="dv">1</span>, cmp);
    sort(a, q + <span class="dv">1</span>, r, cmp);
    <span class="kw">end</span>;
<span class="kw">end</span>;

<span class="kw">begin</span>
  <span class="kw">read</span>(n);
  <span class="kw">for</span> i := <span class="dv">1</span> <span class="kw">to</span> n <span class="kw">do</span>
    <span class="kw">read</span>(a[i]);
  sort(a, <span class="dv">1</span>, n, gr);
  <span class="kw">for</span> i := <span class="dv">1</span> <span class="kw">to</span> n <span class="kw">do</span>
    <span class="kw">write</span>(a[i], <span class="st">&#39; &#39;</span>);
<span class="kw">end</span>.</code></pre>
<p>На языке программирования C:</p>
<pre class="sourceCode C" id="ex41С"><code class="sourceCode c"><span class="ot">#include &lt;stdio.h&gt;</span>

<span class="dt">int</span> i, n;
<span class="dt">int</span> a[<span class="dv">1000</span>];

<span class="dt">void</span> swap(<span class="dt">int</span> *a, <span class="dt">int</span> *b) {
  <span class="dt">int</span> c = *a;
  *a = *b;
  *b = c;
  <span class="kw">return</span>;
}

<span class="dt">int</span> gr(<span class="dt">int</span> a, <span class="dt">int</span> b) {
  <span class="kw">if</span>(a &gt; b)
    <span class="kw">return</span> <span class="dv">1</span>;
  <span class="kw">else</span>
    <span class="kw">return</span> <span class="dv">0</span>;
}

<span class="dt">int</span> partition(<span class="dt">int</span> *a, <span class="dt">int</span> l, <span class="dt">int</span> r, <span class="dt">int</span> (*cmp)(<span class="dt">int</span> a, <span class="dt">int</span> b)) {
  <span class="dt">int</span> i, p = l;
  <span class="kw">for</span>(i = l; i &lt; r; i++)
    <span class="kw">if</span>(cmp(a[i], a[r]) == <span class="dv">1</span>) {
      swap(&amp;a[i], &amp;a[p]);
      p++;
    }
  swap(&amp;a[r], &amp;a[p]);
  <span class="kw">return</span> p;
}

<span class="dt">void</span> sort(<span class="dt">int</span> *a, <span class="dt">int</span> l, <span class="dt">int</span> r, <span class="dt">int</span> (*cmp)(<span class="dt">int</span> a, <span class="dt">int</span> b)) {
  <span class="dt">int</span> q;
  <span class="kw">if</span>(l &lt; r) {
    q = partition(a, l, r, cmp);
    sort(a, l, q - <span class="dv">1</span>, cmp);
    sort(a, q + <span class="dv">1</span>, r, cmp);
  }
}

<span class="dt">int</span> main() {
  <span class="dt">int</span> i, n;
  scanf(<span class="st">&quot;%d&quot;</span>, &amp;n);
  <span class="kw">for</span>(i = <span class="dv">0</span>; i &lt; n; i++)
    scanf(<span class="st">&quot;%d&quot;</span>, &amp;a[i]);
  sort(a, <span class="dv">0</span>, n - <span class="dv">1</span>, gr);
  <span class="kw">for</span>(i = <span class="dv">0</span>; i &lt; n; i++)
    printf(<span class="st">&quot;%d &quot;</span>, a[i]);
  <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h3 id="part4-5">4.5 Задачи для самостоятельной подготовки</h3>
<p>Изобразите блок-схемы алгоритмов для решения предлагаемых задач. Используйте процедуры и функции.</p>
<ol style="list-style-type: decimal">
<li>Найдите все простые числа в диапазоне от 1 до N.</li>
<li>Определите, какие из чисел в наборе являются простыми.</li>
<li>Найдите все палиндромы между двумя четырехзначными числами a и b.</li>
<li>Подсчитайте, сколько палиндромов содержатся в качестве подстрок в заданной строке.</li>
<li>Подсчитайте, сколько различных палиндромов содержатся в качестве подстрок в заданной строке.</li>
<li>Подсчитайте, сколько различных подстрок содержится в заданной строке.</li>
<li>Найдите наибольшую подстроку, встречающуюся в каждой строке из заданного набора.</li>
<li>Найдите наибольшую общую подпоследовательность, встречающуюся в каждой строке из заданного набора.</li>
<li>Найдите лексикографически минимальную строчку из заданного набора.</li>
<li>Для каждой строки матрицы подсчитайте среднее арифметическое.</li>
<li>Для каждого столбца матрицы подсчитайте среднее геометрическое.</li>
<li>Подсчитайте сумму минимумов каждой строки заданной матрицы.</li>
<li>Подсчитайте сумму максимумов каждого столбца заданной матрицы.</li>
<li>Подсчитайте сумму элементов квадратной матрицы, расположенных выше главной диагонали.</li>
<li>Найдите среднее арифметическое массива, образованного из максимальных элементов параллельных основной диагоналей заданной квадратной матрицы.</li>
<li>Найдите среднее геометрическое массива, образованного из минимальных элементов параллельных побочной диагоналей заданной квадратной матрицы.</li>
<li>Определите, сколько различных прямых можно построить на точках из заданного набора.</li>
<li>Выберите из заданного набора точек две, таких что декартово расстояние между ними минимально.</li>
<li>Выберите из заданного набора точек две, таких что манхэттенское расстояние между ними минимально.</li>
<li>Выберите из заданного набора чисел два, таких что хэммингово расстояние между их двоичным представлением минимально.</li>
<li>Для каждого десятичного числа из заданного набора выведите его двоичное представление.</li>
<li>Для каждого десятичного числа из заданного набора выведите его шестнадцатеричное представление.</li>
<li>Для каждого десятичного числа из заданного набора выведите его восьмеричное представление.</li>
<li>Упорядочите заданный набор чисел по возрастанию суммы их цифр.</li>
<li>Упорядочите заданный набор чисел по убыванию произведения их цифр.</li>
<li>Найдите цифровой корень заданного числа.</li>
<li>Подсчитайте значение функции Эйлера от заданного числа.</li>
<li>Подсчитайте остаток от деления числа a в степени b на c.</li>
<li>Найдите наибольший общий делитель двух заданных чисел.</li>
<li>Найдите наименьшее общее кратное двух заданных чисел.</li>
<li>Найдите наименьшее общее кратное для чисел из заданного набора.</li>
<li>Определите, сколько полных квадратов содержится в заданном наборе чисел.</li>
<li>Найдите такую подпоследовательность подряд идущих элементов заданного набора, что их сумма максимальна. Используйте структуру данных &quot;сумматор&quot;.</li>
<li>Найдите такую подпоследовательность подряд идущих элементов заданного набора, что их сумма максимальна. Используйте структуру данных &quot;sqrt-декомпозиция&quot;.</li>
<li>Найдите такую подпоследовательность подряд идущих элементов заданного набора, что их сумма максимальна. Используйте структуру данных &quot;стек&quot;.</li>
<li>Выберите из заданного набора двоичных строк две, таких что расстояние Левенштейна между ними минимально.</li>
<li>Выберите из заданного набора двоичных строк две, таких что расстояние Дамерау-Левенштейна между ними минимально.</li>
<li>Найдите все простые числа в диапазоне от 1 до N. Используйте решето Эратосфена на битовом сжатии.</li>
<li>Найдите все простые числа в диапазоне от 1 до N. Используйте решето Сундарама.</li>
<li>Найдите все простые числа в диапазоне от 1 до N. Используйте решето Аткина.</li>
</ol>
<h2 id="conclude">Заключение</h2>
<p>Для разработки программного обеспечения активно используется множество языков программирования. Решение большинства практических задач часто требует проектирования больших программ со сложной логической структурой, состоящих из сотен, тысяч и даже десятков тысяч операторов. Создание таких программ - труднейший процесс, требующий привлечения всех способностей человека к абстрактному мышлению, поэтому для облегчения восприятия на начальном этапе проектирования ПО удобными могут оказаться графические формы представления - схемы алгоритмов. Язык схем помогает повысить структурность программы, легко усваивается человеком и становится эффективным инструментом общения специалистов как на этапе постановки задачи, так и в процессе проектирования.</p>
</body>
</html>
